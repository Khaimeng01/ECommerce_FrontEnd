import intersectionObserver from 'intersection-observer';
import { __decorate, __param } from 'tslib';
import { ElementRef, Renderer2, NgZone, Inject, PLATFORM_ID, Input, Directive, NgModule } from '@angular/core';
import { isPlatformBrowser } from '@angular/common';

/**
 * Angular Lazy Loading Images Directive
 *
 * The library allows to lazy load images from your web application
 * using the MutationObserver and the IntersectionObserver. Images will be loaded as
 * soon as they enter the viewport in a non-blocking way.
 */
var LazyLoadImagesDirective = /** @class */ (function () {
    function LazyLoadImagesDirective(element, renderer, ngZone, platformId) {
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.platformId = platformId;
        this.rootElement = element.nativeElement;
    }
    LazyLoadImagesDirective.prototype.init = function () {
        var _this = this;
        this.registerIntersectionObserver();
        this.observeDOMChanges(this.rootElement, function () {
            var imagesFoundInDOM = _this.getAllImagesToLazyLoad(_this.rootElement);
            imagesFoundInDOM.forEach(function (image) { return _this.intersectionObserver.observe(image); });
        });
    };
    LazyLoadImagesDirective.prototype.ngOnInit = function () {
        var _this = this;
        if (!this.isBrowser()) {
            return;
        }
        
        this.ngZone.runOutsideAngular(function () { return _this.init(); });
    };
    LazyLoadImagesDirective.prototype.ngOnDestroy = function () {
        if (this.intersectionObserver) {
            this.intersectionObserver.disconnect();
        }
    };
    LazyLoadImagesDirective.prototype.isBrowser = function () {
        return isPlatformBrowser(this.platformId);
    };
    LazyLoadImagesDirective.prototype.registerIntersectionObserver = function () {
        var _this = this;
        this.intersectionObserver = new IntersectionObserver(function (images) { return images.forEach(function (image) { return _this.onIntersectionChange(image); }); }, this.intersectionObserverConfig instanceof Object ? this.intersectionObserverConfig : undefined);
        return this.intersectionObserver;
    };
    LazyLoadImagesDirective.prototype.observeDOMChanges = function (rootElement, onChange) {
        // Create a Mutation Observer instance
        var observer = new MutationObserver(function () { return onChange(); });
        // Observer Configuration
        var observerConfig = {
            attributes: true,
            characterData: true,
            childList: true,
            subtree: true
        };
        // Observe Directive DOM Node
        observer.observe(rootElement, observerConfig);
        // Fire onChange callback to check current DOM nodes
        onChange();
        return observer;
    };
    LazyLoadImagesDirective.prototype.getAllImagesToLazyLoad = function (pageNode) {
        return Array.from(pageNode.querySelectorAll('img[data-src], [data-srcset], [data-background-src]'));
    };
    LazyLoadImagesDirective.prototype.onIntersectionChange = function (image) {
        if (!image.isIntersecting) {
            return;
        }
        this.onImageAppearsInViewport(image.target);
    };
    LazyLoadImagesDirective.prototype.onImageAppearsInViewport = function (image) {
        if (image.dataset.src) {
            this.renderer.setAttribute(image, 'src', image.dataset.src);
            this.renderer.removeAttribute(image, 'data-src');
        }
        if (image.dataset.srcset) {
            this.renderer.setAttribute(image, 'srcset', image.dataset.srcset);
            this.renderer.removeAttribute(image, 'data-srcset');
        }
        if (image.dataset.backgroundSrc) {
            this.renderer.setStyle(image, 'background-image', "url(" + image.dataset.backgroundSrc + ")");
            this.renderer.removeAttribute(image, 'data-background-src');
        }
        // Stop observing the current target
        if (this.intersectionObserver) {
            this.intersectionObserver.unobserve(image);
        }
    };
    LazyLoadImagesDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Renderer2 },
        { type: NgZone },
        { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
    ]; };
    __decorate([
        Input('lazy-load-images')
    ], LazyLoadImagesDirective.prototype, "intersectionObserverConfig", void 0);
    LazyLoadImagesDirective = __decorate([
        Directive({
            selector: '[lazy-load-images]'
        }),
        __param(3, Inject(PLATFORM_ID))
    ], LazyLoadImagesDirective);
    return LazyLoadImagesDirective;
}());

var LazyLoadImagesModule = /** @class */ (function () {
    function LazyLoadImagesModule() {
    }
    LazyLoadImagesModule = __decorate([
        NgModule({
            declarations: [LazyLoadImagesDirective],
            exports: [LazyLoadImagesDirective]
        })
    ], LazyLoadImagesModule);
    return LazyLoadImagesModule;
}());

/*
 * Public API Surface of ngx-lazy-load-images
 */

/**
 * Generated bundle index. Do not edit.
 */

export { LazyLoadImagesDirective, LazyLoadImagesModule };
//# sourceMappingURL=ngx-lazy-load-images.js.map
