import intersectionObserver from 'intersection-observer';
import { __decorate, __param } from 'tslib';
import { ElementRef, Renderer2, NgZone, Inject, PLATFORM_ID, Input, Directive, NgModule } from '@angular/core';
import { isPlatformBrowser } from '@angular/common';

/**
 * Angular Lazy Loading Images Directive
 *
 * The library allows to lazy load images from your web application
 * using the MutationObserver and the IntersectionObserver. Images will be loaded as
 * soon as they enter the viewport in a non-blocking way.
 */
import * as ɵngcc0 from '@angular/core';
let LazyLoadImagesDirective = class LazyLoadImagesDirective {
    constructor(element, renderer, ngZone, platformId) {
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.platformId = platformId;
        this.rootElement = element.nativeElement;
    }
    init() {
        this.registerIntersectionObserver();
        this.observeDOMChanges(this.rootElement, () => {
            const imagesFoundInDOM = this.getAllImagesToLazyLoad(this.rootElement);
            imagesFoundInDOM.forEach((image) => this.intersectionObserver.observe(image));
        });
    }
    ngOnInit() {
        if (!this.isBrowser()) {
            return;
        }
        
        this.ngZone.runOutsideAngular(() => this.init());
    }
    ngOnDestroy() {
        if (this.intersectionObserver) {
            this.intersectionObserver.disconnect();
        }
    }
    isBrowser() {
        return isPlatformBrowser(this.platformId);
    }
    registerIntersectionObserver() {
        this.intersectionObserver = new IntersectionObserver(images => images.forEach(image => this.onIntersectionChange(image)), this.intersectionObserverConfig instanceof Object ? this.intersectionObserverConfig : undefined);
        return this.intersectionObserver;
    }
    observeDOMChanges(rootElement, onChange) {
        // Create a Mutation Observer instance
        const observer = new MutationObserver(() => onChange());
        // Observer Configuration
        const observerConfig = {
            attributes: true,
            characterData: true,
            childList: true,
            subtree: true
        };
        // Observe Directive DOM Node
        observer.observe(rootElement, observerConfig);
        // Fire onChange callback to check current DOM nodes
        onChange();
        return observer;
    }
    getAllImagesToLazyLoad(pageNode) {
        return Array.from(pageNode.querySelectorAll('img[data-src], [data-srcset], [data-background-src]'));
    }
    onIntersectionChange(image) {
        if (!image.isIntersecting) {
            return;
        }
        this.onImageAppearsInViewport(image.target);
    }
    onImageAppearsInViewport(image) {
        if (image.dataset.src) {
            this.renderer.setAttribute(image, 'src', image.dataset.src);
            this.renderer.removeAttribute(image, 'data-src');
        }
        if (image.dataset.srcset) {
            this.renderer.setAttribute(image, 'srcset', image.dataset.srcset);
            this.renderer.removeAttribute(image, 'data-srcset');
        }
        if (image.dataset.backgroundSrc) {
            this.renderer.setStyle(image, 'background-image', `url(${image.dataset.backgroundSrc})`);
            this.renderer.removeAttribute(image, 'data-background-src');
        }
        // Stop observing the current target
        if (this.intersectionObserver) {
            this.intersectionObserver.unobserve(image);
        }
    }
};
LazyLoadImagesDirective.ɵfac = function LazyLoadImagesDirective_Factory(t) { return new (t || LazyLoadImagesDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(PLATFORM_ID)); };
LazyLoadImagesDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: LazyLoadImagesDirective, selectors: [["", "lazy-load-images", ""]], inputs: { intersectionObserverConfig: ["lazy-load-images", "intersectionObserverConfig"] } });
LazyLoadImagesDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: NgZone },
    { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];
__decorate([
    Input('lazy-load-images')
], LazyLoadImagesDirective.prototype, "intersectionObserverConfig", void 0);
LazyLoadImagesDirective = __decorate([ __param(3, Inject(PLATFORM_ID))
], LazyLoadImagesDirective);

let LazyLoadImagesModule = class LazyLoadImagesModule {
};
LazyLoadImagesModule.ɵfac = function LazyLoadImagesModule_Factory(t) { return new (t || LazyLoadImagesModule)(); };
LazyLoadImagesModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: LazyLoadImagesModule });
LazyLoadImagesModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({});
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LazyLoadImagesDirective, [{
        type: Directive,
        args: [{
                selector: '[lazy-load-images]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.NgZone }, { type: undefined, decorators: [{
                type: Inject,
                args: [PLATFORM_ID]
            }] }]; }, { intersectionObserverConfig: [{
            type: Input,
            args: ['lazy-load-images']
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LazyLoadImagesModule, [{
        type: NgModule,
        args: [{
                declarations: [LazyLoadImagesDirective],
                exports: [LazyLoadImagesDirective]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(LazyLoadImagesModule, { declarations: [LazyLoadImagesDirective], exports: [LazyLoadImagesDirective] }); })();

/*
 * Public API Surface of ngx-lazy-load-images
 */

/**
 * Generated bundle index. Do not edit.
 */

export { LazyLoadImagesDirective, LazyLoadImagesModule };

//# sourceMappingURL=ngx-lazy-load-images.js.map